package 额外学习

import (
	"fmt"
	"testing"
)

/*
定义
递归，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。
也就是说，递归算法是一种直接或者间接调用自身函数或者方法的算法。

递归的基本原理
第一：每一级的函数调用都有自己的变量。
第二：每一次函数调用都会有一次返回。
第三：递归函数中，位于递归调用前的语句和各级被调用函数具有相同的执行顺序。
第四：递归函数中，位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反。
第五：虽然每一级递归都有自己的变量，但是函数代码并不会得到复制。

优点
- 实现简单
- 可读性好

缺点
- 递归调用，占用空间大
- 递归太深，易发生栈溢出
- 可能存在重复计算

递归的三大要素
1.明确你的函数想要干什么：先不管函数里面的代码什么，而是要先明白，你这个函数的功能是什么，要完成什么样的一件事。
2.寻找递归结束条件：我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
3.找出函数等价关系式：我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。

递归优化
1、考虑是否重复计算
2、考虑尾递归
*/

/** 练习题 */

// 递归求阶成
// 5 * 4 * 3 * 2 * 1
// 函数： sum = f(n) * f(n - 1)...* f(1)
func factorial(n int) int {
	m := 0
	if n == 1 {
		m = 1
	} else {
		m = n * factorial(n-1)
	}
	return m
}

// 递归求斐波那契数列
// 0 1 1 2 3 5 8 13 21 ...
// 函数: fn = f(n-1) + f(n - 2)
func fib(n int) int {
	if n == 0 {
		return 0
	} else if n == 1 {
		return 1
	} else {
		return fib(n-1) + fib(n-2)
	}
}

// 递归前计算
// 5 + 4 + 3 + 2 + 1
// 函数 sum = f(n) + f(n - 1) + ... f(1)
// 结束条件是参数等于1
func add(n int) int {
	m := 0
	m = m + 5
	if n == 1 {
		return 1
	} else {
		m = m + add(n-1)
	}

	fmt.Println("-----")
	return m + 5
}

// 递归后计算
func add2(n int) int {
	m := 0
	if n == 1 {
		return 1
	} else {
		m = m + add2(n-1)
	}

	fmt.Println("-----")
	return m + 5
}

func Test_digui(t *testing.T) {
	//fmt.Println(factorial(5))
	//fmt.Println(fib(7))
	fmt.Println(add(5))
}
